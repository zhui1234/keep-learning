# 类

## 类的继承

### 1.1基本概念

#### 1.1.1什么是继承

+ 基于已经存在的类创建新类
+ 代码复用

#### 1.1.2术语

+ 父类:被继承的类
+ 子类:继承的类
+ 成员继承:子类获得父类的成员(除private成员)
  
### 1.2语法

```c++
class SonClass:继承方式 FatherClass{
    //子类的成员
};
```

+ 可以用FatherClass&引用子类对象

### 1.3访问权限

+ 子类可以访问父类中的public成员和protected成员
+ 继承方式会将可访问的成员转成指定类型(除了public继承方式下protected成员类型不改变)

### 1.4示例

```C++

```

### 1.5注意事项

1. 子类中初始化函数需要调用父类的初始化函数初始化父类的成员

## 虚函数&虚析构函数

### 2.1基本概念

+ 虚函数是在父类中使用virtual关键字声明的函数
+ 虚函数允许在派生类中重写,实现一个接口多种实现
+ 虚析构函数是父类中使用virtual关键字声明的析构函数
+ 虚构函数是在需要通过父类指针删除对象时确保正确调用子类析构函数

### 2.2语法

#### 2.2.1基本语法

```C++
class FatherClass {
public:
    // 虚函数声明语法
    virtual 返回类型 函数名(参数列表) {
        // 函数实现
    }
    // 虚析构函数声明语法
    virtual ~FatherClass(){
        // 清理代码
    }
};

class SonClass : public FatherClass {
public:
    // 重写虚函数（virtual关键字可选）
    返回类型 函数名(参数列表) override {  
        // 新的函数实现
    }
};
```

+ override:让编译时检查是否重写了虚函数,包括检查参数类型是否一致

#### 2.2.2通过指针/引用实现多态效果

```C++
class Animal {
public:
    virtual void speak() { cout << "Animal sound" << endl; }
};

class Dog : public Animal {
public:
    void speak() override { cout << "Woof!" << endl; }
};

int main() {
    Dog dog;
    Animal* animalPtr = &dog;    // 基类指针指向派生类对象
    Animal& animalRef = dog;     // 基类引用指向派生类对象
    
    animalPtr->speak();  // 输出: Woof! ✅ 多态生效
    animalRef.speak();   // 输出: Woof! ✅ 多态生效
    
    return 0;
}
```

### 2.3访问权限

+ 不能重写private虚函数

### 2.4示例

```C++
#include <iostream>
#include <vector>
using namespace std;

// 基类：使用虚函数和虚析构函数
class Animal {
public:
    // 虚函数 - 实现多态
    virtual void speak() const {
        cout << "Animal sound" << endl;
    }
    
    // 虚析构函数 - 确保正确清理资源
    virtual ~Animal() {
        cout << "Animal destroyed" << endl;
    }
};

// 派生类
class Dog : public Animal {
private:
    string* data;  // 动态分配的资源
public:
    Dog() {
        data = new string("Dog's private data");
        cout << "Dog created" << endl;
    }
    
    void speak() const override {
        cout << "Woof! Woof!" << endl;
    }
    
    ~Dog() override {
        delete data;  // 释放资源
        cout << "Dog destroyed" << endl;
    }
};

class Cat : public Animal {
public:
    void speak() const override {
        cout << "Meow!" << endl;
    }
    
    ~Cat() override {
        cout << "Cat destroyed" << endl;
    }
};

// 使用多态的函数
void makeAnimalSpeak(Animal* animal) {
    animal->speak();  // 多态调用
}

int main() {
    cout << "=== 测试虚函数的多态 ===" << endl;
    Animal* animals[] = {new Dog(), new Cat()};
    
    for (Animal* animal : animals) {
        makeAnimalSpeak(animal);  // 调用各自的重写函数
    }
    
    cout << "\n=== 测试虚析构函数 ===" << endl;
    for (Animal* animal : animals) {
        delete animal;  // 正确调用所有析构函数
    }
    
    return 0;
/*
=== 测试虚函数的多态 ===
Dog created
Woof! Woof!
Meow!

=== 测试虚析构函数 ===
Dog destroyed
Animal destroyed
Cat destroyed
Animal destroyed
*/
}
```

### 2.5注意事项

+ 虚函数的多态效果只有通过父类的指针或引用调用时才会发生

## 纯虚函数&抽象类

### 3.1基本概念

+ 纯虚函数:在父类中声明但不实现的虚函数(子类中必须实现)
+ 抽象类:包含至少一个纯虚函数,不能创建对象的类
+ 抽象类主要用于作为其他类的父类

### 3.2语法

#### 3.2.1基本语法

```C++
class AbstractClassName {
public:
    // 纯虚函数
    virtual 返回类型 函数名(参数列表) = 0;
    
    // 虚析构函数
    virtual ~AbstractClassName() = default;
};
```

#### 3.2.2指针和引用

```C++
AbstractAnimal* ptr;        // 声明指针变量

Dog dog;
AbstractAnimal& ref = dog;  // 声明引用变量
```

### 3.3注意事项

+ 不能创建抽象类对象,可以声明指针和引用
+ 子类必须实现所有纯虚函数
+ 纯虚函数必须有虚析构函数

## 数据抽象&数据封装

### 4.1基本思想

+ 隐藏实现细节,只提供接口
