# 学习笔记

[TOC]

## 1.编码

> [锟斤拷�⊠是怎样炼成的——中文显示“⼊”门指南【柴知道】](https://www.bilibili.com/video/BV1cB4y177QR/?share_source=copy_web&vd_source=9eebc0e143eff42351285a99b6d32e9a)
> ~~找到一个多年前看过的视频，讲得很清晰~~

### 1.1.理解编码

编码是一种对应关系,将字符与二进制数一一对应

### 1.2.常见编码

1.ASCII
2.GB2312(936) / GBK(936) / GB18030(54936)
3.UTF8(65001) / UTF16 / UTF32
> 括号内为编码对应的代码页编号

### 1.3.乱码原因

编码与解码方案不匹配

1. 源文件编码与编译器假设不匹配
2. 输出编码与终端编码不匹配

### 1.4.解决措施

核心：设置UTF-8编码

1. 使用system()函数

    ```C++
        system("chcp 65001 >nul");//"chcp 65001":将控制台代码页设置为65001 
                              //">nul":将命令的输出重定向到空设备，即隐藏命令执行结果
    ```

    > `system()`包含于`cstdlib`头文件中

2. 使用SetConsoleOutputCP()

    ```C++
        SetConsoleOutputCP(65001); //设置控制台输出编码为65001
                                   //类似的SetConsoleCP:设置控制台输入编码
    ```

    > `SetConsoleOutputCP`包含于`windows.h`头文件中
    > 可以在`#include<windows.h>`以及`SetConsoleOutputCP(65001);`前后分别加上`#ifdef WIN_32`及`#endif`确保在其他平台的兼容性
    > 可以在中文字符串前加上`u8`前缀确保字符串以UTF-8编码存储

3. way3 使用宽字符

    ```C++
    #include <iostream>
    #include <locale>
    #include <io.h>//提供底层io操作(输入 输出 打开/关闭文件等)和文件描述符操作(修改文件模式)
    #include <fcntl.h>//定义了常用文件打开方式(只读 只写等)和Unicode相关模式(UTF-8 UTF16等)

    int main()
    {
        _setmode(_fileno(stdout), _O_U8TEXT);//用U8还是U16取决于文件编码,不能用_O_WTEXT,会与C++标准流冲突
        /*经测试,环境配置好时不需要以下代码
        std::locale::global(std::locale(""));//设置全局C++本地化环境
        std::wcout.imbue(std::locale());//设置宽字符输出流的locale
        std::wcin.imbue(std::locale());设置宽字符输入流的locale
        */
        std::wcout << L"中文" << '\n';
        return 0;
    }
    ```

    > 宽字符使用std中的`wchar_t`(存储多字节字符),`wstring`,`wcin`,`wcout`
    > 宽字符/字符串前要加个`L`

## 2.类(图形输出)

### 2.1.结构

```C++
class 类名
{
    类访问修饰符:
        (static) 变量类型 (静态)变量/函数
        类名(参数):{} //构造函数
};
```

### 2.2.类访问修饰符

> `private` 在类的外部不可访问,需要使用成员函数来访问和修改,无访问修饰符默认为私有成员
> `public` 在类的外部可访问,可以不使用成员函数来访问和修改
> `protected` 与`private`类似,但可以在派生类访问和修改

### 2.3.特殊符号

> `.` 访问类的public成员 用法: 对象.成员变量/函数
> `::` 访问类的静态成员/在类外部定义成员函数 类名::静态成员名/函数

### 2.4.静态成员

> 在所有对象间共享
> 必须在类外初始化

### 2.5.示例

```C++
class Box
{
    private:
        double length,width,height;
    public:
        static int num;
        Box(double l,double w,double h):length(l),width(w),height(h)  //构造函数
        {
            num++;
        }
        double get_volume();
};
int Box::num=0; //初始化静态成员变量

double Box::get_volume()
{
    return length*width*height;
}

int main()
{
    Box Box1(1.0,2.0,3.0);
    cout<<Box1.get_volume()<<'\n'<<Box::num;
    return 0;
}
```

## 3.(猜数字)

## 4.正则表达式(计算器)

### 4.1.认识正则表达式

正则表达式是一种描述字符序列的方法
默认的正则表达式语言是'ECMAScript'.

### 4.2.正则表达式组件库

#### 4.2.1.变量类型

> regex // 表示有一个正则表达式的类
> smatch // 存储字符串匹配结果

#### 4.2.2.常用组件

> `R"(...)"` --> 表示原始字符串字面量,允许字符串中包含特殊字符而无需转义
> `(... | ... | ...)` --> 表示匹配,捕获并分组`(\+|\-)`
> `[...]` --> 表示匹配`[abc][+-][a-z][A-Za-z]`
> `(?:...)` --> 表示非捕获分组
> 例如 `regex r(R"((\+|\-)?\d+(\.\d+)?)");` 存储一个可以匹配数字的正则表达式  

#### 4.2.3.特殊符号

> `^...` -->在`[]`内表示非,在`[]`外表示开始
> `...$` -->表示结束
> `\...` --> 转义符号  `[+-]`无需转义,`(\+|\-)`有`|`需转义
> `-`    --> 范围运算符
> `...`  --> 匹配一个式子
> `...?` --> 匹配0次或1次
> `...+` --> 匹配一个或多个式子
> `...*` --> 匹配零个或多个式子

#### 4.2.4.常用字符类

> `.`  --> 匹配除回车任意字符
> `\s` --> 匹配空白字符(空格/换行等)
> `\d` --> `[\d]=[0-9]`
> `\w` --> `[\w]=[a-zA-Z0-9_]`
> `[:space:]` --> `[[:space:]]=[\s]`
> `[:digit:]` --> `[[:digit:]]=[0-9]`
> `[:alpha:]` --> `[[:alpha:]]=[a-zA-Z]`
> `[:lower:]` --> `[[:lower:]]=[a-z]`
> `[:upper:]` --> `[[:upper:]]=[A-Z]`

#### 4.2.5.正则表达式常用函数

> `regex_match(seq,r)` --> 确定字符序列seq与regex对象r是否匹配,匹配则返回true
> `regex_search(seq,m,r)` --> 寻找字符序列seq中与regex对象r匹配的子串,找得到则返回true,同时把匹配结果存在smatch对象m中
> `regex_replace(seq,r,fmt)` --> 寻找字符序列seq中与regex对象r匹配的子串,使用fmt来替代输出,返回一个替换后的字符串

#### 4.2.6.示例

```C++
#include<iostream>
#include<regex>
#include<string>
using namespace std;

const double Limit=10000.0;
class Calculator
{
private:
    static const regex formula; // 正则表达式对象,用于匹配输入的表达式
    void calculate(double a,double b,char op); // 计算函数
public:
    bool preprocess(string expression); // 预处理输入的表达式,包括语法检查和调用计算函数
    
};

const regex Calculator::formula(R"(\s*([+-]?\d+(?:\.\d+)?)\s*([+\-*/])\s*([+-]?\d+(?:\.\d+)?)\s*)"); // 匹配形如"1+1"或"1 + 1"的表达式

bool Calculator::preprocess(string expression)
{
    {
        smatch parts;
        if(!regex_match(expression,parts,formula)) // 如果表达式不符合正则表达式的规则
        {
            cout<<"Expression error!"<<'\n';
            return 0;
        }
        double a,b;
        char op;
        a=stod(parts[1].str());
        op=parts[2].str()[0];
        b=stod(parts[3].str());
        if(a<-Limit || a>Limit || b<-Limit || b>Limit) // 如果数字超出范围
        {
            cout<<"Number out of range!"<<'\n';
            return 0;
        }
        if(op=='/' && b==0) // 如果除数为零
        {
            cout<<"Division by zero!"<<'\n';
            return 0;
        }
        calculate(a,b,op);
        return 1;
    }
}
void Calculator::calculate(double a,double b,char op)
{
    double result;
    switch(op)
    {
        case '+':
            result=a+b;
            break;
        case '-':
            result=a-b;
            break;
        case '*':
            result=a*b;
            break;
        default:
            result=a/b;
            break;
    }
    cout<<a<<" "<<op<<" "<<b<<" = "<<result<<'\n';
}

int main()
{
    cout<<"请用户输入单项数学式(输入'exit'退出)\n";
    Calculator calc;
    while(1)
    {
        string expression;
        getline(cin,expression);
        if(expression=="exit")
            break;
        if(!calc.preprocess(expression))
            cout<<"\n请重新输入\n";
        else
            cout<<"\n请继续输入\n";
    }
    return 0;
}
```

## 5.排序算法

### 5.1.快速排序

#### 5.1.1.思想

> 分治:选取基准元素x,将所有元素分为小于x和大于x的两部分,不断划分直至剩下一个元素
> 平均时间复杂度为O(nlogn)
> 当整体有序时,效率很低,最坏时间复杂度为O(n)

#### 5.1.2.优化方式

1. 三数取中

### 5.2.插入排序

#### 5.2.1.思想

> 类似于扑克牌洗牌,对于第i个元素,在0~i范围内找到其位置并插入

#### 5.2.2.优化方式

1. 使用`lower_bound`二分

## 6.模板

个人理解:对于一些与类型无关的代码,使用模板能避免程序冗杂,让一段程序能够处理多种类型

### 6.1基本语法

1. 函数模板

    ```C++
    template<typename T>
    T max(T a,T b)
    {
        return a>=b?a:b;
    }
    ```

2. 类模板

    ```c++
    template<typename T>
    class Box
    {
    private:
        T length,width,height;
    public:
        static int num;
        Box(T l,T w,T h):length(l),width(w),height(h)  //构造函数
        {
            num++;
        }
        T get_volume();
    };
    int Box::num=0; //初始化静态成员变量

    template<typename T>
    T Box::get_volume()
    {
        return length*width*height;
    }

    int main()
    {
        Box Box1(1.0,2.0,3.0);
        cout<<Box1.get_volume()<<'\n'<<Box::num;
        return 0;
    }
    ```

3. 其他操作
    > `is_same_v<T,double>` -->检查T与double是否相同,返回bool
    > `if constexpr ()` --> 编译时条件判断,只有满足条件的代码块才会被编译
